# react-shopping-cart

## 📍 학습 목표

- ✔️ 상태를 중복 없이 구성하고, 계산이 가능한 값은 파생 상태로 도출하여 관리할 수 있다.
- ✔️ 함수(컴포넌트, 훅, util)가 단일한 책임만 갖도록 분리하고, 그 책임에 맞는 명확한 인터페이스를 정의할 수 있다.

### step2 시작전 리팩토링

- [x] CartItem 컴포넌트 네이밍 변경 (범용적)
- [ ] 불필요한 리렌더링 최적화하기 (CartPage)
- [x] CartItem 훅 내부 로직 분리
- [x] Checked ids 분리
- [x] 초기진입시, 체크 박스 풀 체크
- [ ] CartItem 훅 내부 로직 context API로 관리 -> CartContext
- [ ] isChecked 값 {id:checked} 매치해서 배열로 관리?
- [ ] 각각의 페이지에서 context 적용
- [ ] useQuery와 useMutation 적용

### 설계

"코로케이션 폴더"라는 용어는 일반적으로 웹 개발, 특히 Next.js와 같은 프레임워크에서 사용되는 "코로케이션(colocation)"이라는 디자인 패턴과 관련되어 있습니다. 이는 파일을 폴더 구조 내에 함께 위치시켜 관련 코드, 데이터, 페이지를 연결하여 관리 효율성을 높이는 방식입니다.

- context 생성

  - 상위에서 useCart, useInformation(도서산간지역 여부), useCoupon(인자 - cart상태, 총 가격)
    - or usePrice?
  - useCart에서 현재 내려주는 값을 그대로 유지할지 (context로 다 내려주기)
  - 필수로 필요핝 cart상태만 내려주고, 페이지에서 필요한 값들 가공해서 사용하게 할지

- 뭔가 계산 하는 로직들은 utils로 분리해서 관리해야할듯 (함수)

그럼 로컬스토리지에 저장해야하는 값은 무엇인가 -> 카트 상태만 관리한다?

### 기능명세서

- [x] order-confirm -> payment-confirm 페이지로 변경

- [ ] ui 퍼블리싱
  - [x] 주문확인 페이지 (orderConfirmPage)
    - [x] 쿠폰 적용 버튼
    - [x] 배송 정보 여부 체크
    - [x] OrderPrice 컴포넌트
  - [x] 쿠폰 모달 (호이초이 모달 사용)
    - [x] 체크 박스 및 쿠폰 정보
    - [x] 쿠폰 적용 버튼
    - [x] 쿠폰 컴포넌트
  - [ ] 결제 확인 페이지
    - [ ] 장바구니로 돌아가기 버튼
- [ ] 훅 분리 (?)
  - [ ] useCart (장바구니 상품 아이템들)
  - [ ] usePrice (가격들만 관리)
  - [x] useOrder
- [x] 상태 추가
  - [x] isRemoteArea (제주도 및 도서 산간 지역) (이건 배송지 정보로 들어가지 않을까?)
  - [ ] coupons 상태 (기존 서버에서 쿠폰정보 받아오고, 여기에 isChecked 값 부여)
    - 이렇게 할 경우, 계산 로직이 복잡해질 수 있다.
    - [ ]
- [ ] msw 쿠폰 조회 로직 작성
- [ ] 테스트 코드 작성

### 응집도와 결합도 측면에서의 대화

책임이 여러개이긴 하지만, 사용이 편리하다.
책임의 주체를 기능이 아니라, 상태로 본다.
파생 되는 값이니까, 한번에 모아두면 좋다.
응집도가 낮다.

1. useCart 안에 로직 다 모아두기
   - 파일이 흩어지는 것 같다. -> 그냥 모아두는게 더 좋은 것 같다. 분리를 안 하고.
   - cartItems 에 의해서 다 계산되기 때문에. 이걸 utils 로 분리해봤자 재사용도 안되고, cartItems 맥락에서 밖에 쓰인다.
   - 그럴바에야 모아두자. 재사용이 안될거같다.
   - 밍고도 마찬가지. 리뷰어가 분리하라고 함. Context 로 cart 를 내보내고, 다른 데에서 값을 받아서 hook 으로 만듦.
2. useCart 를 그대로 쓰되, 안에 로직을 모두 별도로 분리한다. useCart 의 역할은 다 결합시켜서 내려주는 Wrapper 에 불과하다.
3. useCart 를 없애고, useGetCartItems, useDeleteCart, useUpdateCart, useOrderInfo 등 다 나누고, 사용처에서 그에 맞게 쓴다.
   변경을 고려하지 않고 있다.
   가독성을 높이기 위해서, 그냥 다 결합시키는게 좋다. 추상화 시키면 오히려 코드가 어렵다. 근데 유지보수성은 좋다진다.
   유지보수성이 좋아진다는 것은, 변경에 대응하기 쉽다는 것이다.
   원칙. - ISP, SRP, DIP 등등 다 지킬 수 있는 방안
   변경.
   DI(의존성 주입) - 주입을 해줘야하는데,

### 고민 사항

page 딴에서 데이터를 전달하는게 맞을까?
아님, 전역 상태를 하나를 두고, 해당 페이지에서 원하는 값들을 긁어다가 쓰는게 맞을까?

- 전역 상태의 경우, 하나의 공유 저장소같은 느낌

기존의 경우) 페이지 이동할 때, 해당 데이터를 서버의 DB에 저장을 해두고, 페이지 딴에서 서버 요청을 해서 최신 데이터를 가지고 오고 이를 UI상에 뿌려주는게 맞지 않을까? 라는 생각
